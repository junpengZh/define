# **宏定义、宏函数和内联函数**

### 宏是什么：

宏（#define）命令是C语言中的一个宏定义命令,它用来将一个标识符定义为一个字符串,该标识符被称为宏名，被定义的字符串称为替换文本。

**提高效率、可读性、易改性，核心是替换**

**#define  标识符  字符串**

该命令有两种格式:

①**简单**的宏定义

②**带参数**的宏定义。

## 一、简单宏定义：

![](D:\QQ\MobileFile\IMG_20240107_144803.jpg)

#define N 100就是宏定义。N为宏名，100是宏的内容。预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。这样做的优势是

宏定义是由源程序中的宏定义命令#define完成的，宏替换是由预处理程序完成的。

#### 简单宏替换出现的问题：

但是我们在宏替换时会出现以下这类问题：

![](D:\QQ\MobileFile\IMG_20240107_144828.jpg)

我们预想的是输出结果为：a=16

然而实际结果却为：a=8

原因：在宏替换的时候编译器在预处理阶段只是进行简单的文本替换，所以预处理后的代码为：

![](D:\QQ\MobileFile\IMG_20240107_144921.jpg)

所以一般情况下要想达到我们预期的目的，应该在应替换的宏内容加括号：

![](D:\QQ\MobileFile\IMG_20240107_144949.jpg)

## 二、带参数的宏定义（宏函数）：

也就是我们常说的宏函数也是在预处理阶段进行文本替换，只不过多了个参数，它形如函数

常见使用方法：#define A(x) x

![](D:\QQ\MobileFile\IMG_20240107_145018.jpg)

解释：

2+2就是传给x的参数，而此参数也是纯文本，即：x在被替换的时候就是纯文本2+2，不进行任何计算和修饰

它也是一种纯文本替换，实际输出结果为：8，并非16

所以我们为了避免逻辑出错，在替换文本处加括号：

![](D:\QQ\MobileFile\IMG_20240107_145048.jpg)

### 重点：

```
#define foo(x) bar(x); baz(x)
```

然后你可能这样调用：

```
foo(wolf);
```

这将被宏扩展为：

```
bar(wolf); baz(wolf);
```

这的确是我们期望的**正确输出**。

下面看看如果我们这样调用：

```
if  (!feral)`   
    foo(wolf);
```

那么扩展后可能就不是你所期望的结果。

上面语句将扩展为:

```
if  (!feral)   
     bar(wolf);
 baz(wolf);
```

显而易见，这是错误的，也是大家经常易犯的错误之一。

### 此时，有人会想用大括号可以解决

我们用大括号来定义宏如下：

```
#define foo(x)  { bar(x); baz(x); }
```

这对于上面举的if语句的确能被正确扩展，但是如果我们有下面的语句调用呢：

```
if  (!feral)
    foo(wolf);
else     
    bin(wolf);
```

宏扩展后将变成：

```
if  (!feral) {
   bar(wolf);
   baz(wolf);
};
else
    bin(wolf);
```

大家可以看出，这就有语法错误了。



几乎在所有的情况下，期望写多语句宏来达到正确的结果是不可能的。你不能让宏像函数一样行为——在没有**do/while(0)**的情况下。

**do{...}while(0)在C中是唯一的构造程序**，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。

这句话听起来可能有些拗口，其实用一句话概括就是：**使用do{...}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。**

如果我们使用**do{...}while(0)**来重新定义宏，即：

```
#define foo(x) do { bar(x); baz(x); } while (0)
```

现在，该语句功能上等价于前者，do能确保大括号里的逻辑能被执行，而while(0)能确保该逻辑只被执行一次，即与没有循环时一样。

对于上面的if语句，将会被扩展为：

```
if  (!feral)    
do  { bar(wolf); baz(wolf); }  while  (0);
```

从语义上讲，它与下面的语句是等价的：

```
if  (!feral) {
     bar(wolf);
     baz(wolf);
}
```



### 宏的优点：

#### 1.提高运行效率

用宏函数代替普通函数调用可以节省系统开销，提高运行效率，因为它不像普通函数那样需要开辟栈帧。

#### 2.代码便于修改

需要对代码进行维护的时候，我们只需要更改宏体就能对整个代码进行维护，没必要一个个的去改

#### 宏的缺陷，内联函数的引入

宏虽然有着一定的优势，但是它的缺点也不可忽视。在编译阶段，我们就不好发现代码哪里出问题了，因为宏替换是发生在预处理阶段，所以有时候在宏函数传参的时候发生一些错误，编译器不会发现，那它调试起来就很麻烦。

所以为了解决这种问题，我们就有了内联函数

##### 内联函数（空间换时间）

概念：以inline修饰的函数叫做内联函数，编译阶段（更加安全）C++编译器会在调用函数的地方展开，没有压栈开销，内联函数提升程序运行效率。

特性：

1. inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。
2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联。
3.  inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。







http://t.csdnimg.cn/2Gh2p

http://t.csdnimg.cn/A4ibE

http://t.csdnimg.cn/0dyBk